//17.小 S 与时间逆流
// 【题目描述】
// 小 S 是一名时空旅行者，她喜欢在不同的异世界见证文明的发展史。
// 一个持续时间为 |S| 的文明的发展史可以被记录为一个长度为 |S| 的 01 串，0 代表
// 这个文明处于和平时期，1 代表处于战争时期。
// 但是旅行结束后，小 S 发现这个世界发生了正好一次可怕的时间逆流！这打乱小 S
// 已经做好的文明记录！但是由于在异世界中感受不到时间逆流，小 S 并不知道它发生在
// 了哪一段时间中。
// 简单来说，一次时间逆流对文明记录的影响是，将这段时间内的记录翻转。
// 这里 01 串的下标从 1 开始。
// 现在小 S 需要修复这个记录，虽然他不知道具体哪一段时间区间受到了翻转。但是
// 她印象中这个文明的战争更多的发生在晚期。也就是说，字典序最小的修复后的文明记
// 录 T 应该就是正确的。
// 不过小 S 现在在被她的妹妹拉去玩游戏，所以请你帮帮她找到这个正确的记录。
// 【输入格式】
// 输入只有一行一个字符串，表示被打乱的文明记录 S。
// 【输出格式】
// 输出一行一个字符串，表示得到的正确文明记录 T ，其字典序应该是所有可能的
// 文明记录中最小的。
// 【样例 1 输入】
// 1 101
// 【样例 1 输出】
// 1 011
// 【样例 2 输入】
// 1 0010100
// 【样例 2 输出】
// 1 0000101
// 【子任务】
// 对 100% 的数据，1 ≤ |S| ≤ 100。S 只含字符 0, 1。其中 |S| 表示输入字符串的长度。
// #include <stdio.h>
#include <string.h>
void reverse(char *str, int l, int r) {
    while (l < r) {
        char temp = str[l];
        str[l] = str[r];
        str[r] = temp;
        l++;
        r--;
    }
}
void find(char *S) {
    int n = strlen(S);
    char minT[101]; // 存储字典序最小的结果
    strcpy(minT, S); // 初始化为原字符串
    for (int l = 0; l < n; l++) {
        for (int r = l; r < n; r++) {
            char T[101]; // 存储当前翻转后的字符串
            strcpy(T, S); // 复制原字符串到 T
            // 翻转区间 [l, r]
            reverse(T, l, r);
            // 比较字典序，更新最小的 T
            if (strcmp(T, minT) < 0) {
                strcpy(minT, T);
            }
        }
    }
    // 输出结果
    printf("%s", minT);
}
int main() {
    char S[101]; // 输入字符串
    scanf("%s", S); // 读取输入
    find(S); // 处理并输出结果
    return 0;
}

//学会使用strcmp，strcpy，strlen等string.h中的函数
//了解字典序是什么