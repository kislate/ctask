//24.方程求解
// 【题目描述】
// 小 A 有 n 个关于 x 的方程，第 i 个方程形如 aixi + bi = ci。方程的解 x 均为正整
// 数，例如下面几个方程都是符合要求的方程：
// 1 2x+4=10
// 2 ‐3x+13=10
// 3 4x‐8=16
// 其中，第一组方程的解为 x1 = 3，第二组方程的解为 x2 = 1，第三组方程的解为
// x3 = 6。
// 小 A 想要知道，给定 L, R，在 L ≤ x ≤ R 的范围内，有多少个正整数 x 满足 x 是
// 其中至少一个方程的解。为了防止你欺骗他，他会询问你 Q 次。
// 【输入格式】
// 第一行输入两个正整数 n, Q，分别表示小 A 有的方程数，以及小 A 想要向你询问
// 的次数。
// 第二行开始，往下 n 行，每行一个字符串，描述一个方程。
// 第 (n + 2) 行开始，往下 Q 行，每行两个正整数 L, R，表示一次询问，即给定 L, R，
// 询问在 L ≤ x ≤ R 的范围内，有多少个正整数 x 满足 x 是其中至少一个方程的解。
// 【输出格式】
// 对于每次询问，输出一行一个整数，表示有多少个在 L ≤ x ≤ R 的范围内的正整
// 数 x，满足 x 是其中至少一个方程的解。
// 【样例 1 输入】
// 1 3 4
// 2 2x+4=10
// 3 ‐3x+13=10
// 4 4x‐8=16
// 5 1 6
// 6 1 8
// 7 3 6
// 8 4 5
// 【样例 1 输出】
// 1 3
// 2 3
// 3 2
// 4 0
// 【样例 1 解释】
// 对于第一组样例，即为题目中的举例。三组方程的解分别为 x1 = 3, x2 = 1, x3 = 6。
// 则：
// • 对于 1 ≤ x ≤ 6 的范围，有 3 个 x 的取值（x = 1, 3, 6）是其中至少一个方程的
// 解；
// • 对于 1 ≤ x ≤ 8 的范围，同上所述；
// • 对于 3 ≤ x ≤ 6 的范围，有 2 个 x 的取值（x = 3, 6）是其中至少一个方程的解；
// • 对于 4 ≤ x ≤ 5 的范围，不存在一个 x 是其中至少一个方程的解；
// • 因此分别输出 3, 3, 2, 0。
// 【样例 2 输入】
// 1 5 3
// 2 5x‐2=13
// 3 8x+5=45
// 4 4x‐12=8
// 5 ‐2x+10=4
// 6 3x‐7=2
// 7 1 3
// 8 1 5
// 9 3 5
// 【样例 2 输出】
// 1 1
// 2 2
// 3 2
// 【样例 2 解释】
// 对于第二组样例，五组方程的解分别为 x1 = 3, x2 = 5, x3 = 5, x4 = 3, x5 = 3。则：
// • 对于 1 ≤ x ≤ 3 的范围，只有 x = 3 满足是其中至少一个方程的解；
// • 对于 1 ≤ x ≤ 5 的范围，有 2 个 x 的取值（x = 3, 5）是其中至少一个方程的解；
// • 对于 3 ≤ x ≤ 5 的范围，有 2 个 x 的取值（x = 3, 5）是其中至少一个方程的解；
// • 因此分别输出 1, 2, 2。
// 【子任务】
// 数据保证，1 ≤ n, Q ≤ 2 × 105，方程中 ai, bi, ci 满足 1 ≤ |ai|, |bi|, |ci| ≤ 109，
// 每一组方程的解 xi 必定为正整数。询问时的 L, R 满足 1 ≤ L ≤ R ≤ 2 × 109。
// 本题输入数据较大，请注意代码输入输出的运行效率。
// 【hints】
// 将方程作为字符串处理，是否有一些繁琐？
// 可否通过 getchar 函数，自行实现一个输入函数，忽略其他字符，只读入数字？
// 上面的函数被称为快速读入函数，可查阅资料学习。
#include<stdio.h>
int main()
{
	int n, Q;
	scanf("%d %d", &n, &Q);
	int a[n], b[n], c[n];
	for (int i = 0; i < n; i++)
	{
		scanf("%d", &a[i]);
		getchar();
		scanf("%d", &b[i]);
		getchar();
		scanf("%d", &c[i]);
	}
	for (int i = 0; i < Q; i++)
	{
		int L, R;
		scanf("%d %d", &L, &R);
		int ans = 0;
		for (int j = L; j <= R; j++)
		{
			for (int k = 0; k < n; k++)
			{
				if (a[k] * j + b[k] == c[k])
				{
					ans++;
					break;
				}
			}
		}
		printf("%d\n", ans);
	}
	return 0;
}