[33mcommit 79d9fabae9a19c78e81cc8824141da0ae0bbae35[m
Author: kislate <2979574787@qq.com>
Date:   Wed Jun 11 01:12:01 2025 +0800

    字符串速通

[1mdiff --git "a/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P1481_\351\255\224\346\227\217\345\257\206\347\240\201.md" "b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P1481_\351\255\224\346\227\217\345\257\206\347\240\201.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..e1410c4[m
[1m--- /dev/null[m
[1m+++ "b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P1481_\351\255\224\346\227\217\345\257\206\347\240\201.md"[m
[36m@@ -0,0 +1,95 @@[m
[32m+[m[32m# P1481 魔族密码[m
[32m+[m
[32m+[m[32m## 题目背景[m
[32m+[m
[32m+[m[32m风之子刚走进他的考场，就……[m
[32m+[m
[32m+[m[32m花花：当当当当~~偶是魅力女皇——花花！！^^（华丽出场，礼炮，鲜花）[m
[32m+[m
[32m+[m[32m风之子：我呕……（杀死人的眼神）快说题目！否则……-\_-###[m
[32m+[m
[32m+[m[32m## 题目描述[m
[32m+[m
[32m+[m[32m花花：……咦~~好冷~~我们现在要解决的是魔族的密码问题（自我陶醉：搞不好魔族里面还会有人用密码给我和菜虫写情书咧，哦活活，当然是给我的比较多拉\*^\_^\*）。[m
[32m+[m
[32m+[m[32m魔族现在使用一种新型的密码系统。每一个密码都是一个给定的仅包含小写字母的英文单词表，每个单词至少包含 $1$ 个字母，至多 $75$ 个字母。如果在一个由一个词或多个词组成的表中，除了最后一个以外，每个单词都被其后的一个单词所包含，即前一个单词是后一个单词的前缀，则称词表为一个词链。例如下面单词组成了一个词链：[m
[32m+[m
[32m+[m[32m- $\verb!i!$；[m
[32m+[m[32m- $\verb!int!$；[m
[32m+[m[32m- $\verb!integer!$。[m
[32m+[m
[32m+[m[32m但下面的单词不组成词链：[m
[32m+[m
[32m+[m[32m- $\verb!integer!$；[m
[32m+[m[32m- $\verb!intern!$。[m
[32m+[m
[32m+[m[32m现在你要做的就是在一个给定的单词表中取出一些词，组成最长的词链，就是包含单词数最多的词链。将它的单词数统计出来，就得到密码了。[m
[32m+[m
[32m+[m[32m风之子：密码就是最长词链所包括的单词数阿……[m
[32m+[m
[32m+[m[32m## 输入格式[m
[32m+[m
[32m+[m[32m这些文件的格式是，第一行为单词表中的单词数 $N$（$1 \le N \le 2000$），下面每一行有一个单词，按字典顺序排列，中间也没有重复的单词。[m
[32m+[m
[32m+[m[32m## 输出格式[m
[32m+[m
[32m+[m[32m输出共一行，一个整数，表示密码。[m
[32m+[m
[32m+[m[32m## 输入输出样例 #1[m
[32m+[m
[32m+[m[32m### 输入 #1[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32m5[m
[32m+[m[32mi[m
[32m+[m[32mint[m
[32m+[m[32minteger[m
[32m+[m[32mintern[m
[32m+[m[32minternet[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 输出 #1[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32m4[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m##  非常简单的一道dp[m
[32m+[m[32m```cpp[m
[32m+[m[32m#include <bits/stdc++.h>[m
[32m+[m[32musing namespace std;[m
[32m+[m[32mint n, ans = 0;[m
[32m+[m[32mvector<vector<string>> s(26);[m
[32m+[m[32mvector<vector<int>> dp(26);[m
[32m+[m[32mbool match(string &a, string &b)[m[41m [m
[32m+[m[32m{[m
[32m+[m[32m    return a == b.substr(0, a.size());[m
[32m+[m[32m}[m
[32m+[m[32mint main(void)[m
[32m+[m[32m{[m
[32m+[m[32m    cin >> n;[m
[32m+[m[32m    for(int i = 0; i < n; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        string temp;[m
[32m+[m[32m        cin >> temp;[m
[32m+[m[32m        s[temp[0] - 'a'].push_back(temp);[m
[32m+[m[32m        dp[temp[0] - 'a'].push_back(1);[m
[32m+[m[32m    }[m
[32m+[m[32m    for(int i = 0; i < 26; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        for(int j = s[i].size() - 1; j >= 0; j--)[m
[32m+[m[32m        {[m
[32m+[m[32m            for(int k = j + 1; k < s[i].size(); k++)[m
[32m+[m[32m            {[m
[32m+[m[32m                if(match(s[i][j], s[i][k]))[m
[32m+[m[32m                {[m
[32m+[m[32m                    dp[i][j] = max(dp[i][j], dp[i][k] + 1);[m
[32m+[m[32m                    ans = max(ans, dp[i][j]);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    cout << ans << endl;[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
\ No newline at end of file[m
[1mdiff --git "a/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P2580_\351\224\231\350\257\257\347\232\204\347\202\271\345\220\215.md" "b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P2580_\351\224\231\350\257\257\347\232\204\347\202\271\345\220\215.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..0d1e7f1[m
[1m--- /dev/null[m
[1m+++ "b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P2580_\351\224\231\350\257\257\347\232\204\347\202\271\345\220\215.md"[m
[36m@@ -0,0 +1,96 @@[m
[32m+[m[32m# P2580 于是他错误的点名开始了[m
[32m+[m
[32m+[m[32m## 题目背景[m
[32m+[m
[32m+[m[32mXS中学化学竞赛组教练是一个酷爱炉石的人。[m
[32m+[m
[32m+[m[32m他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。[m
[32m+[m
[32m+[m[32m## 题目描述[m
[32m+[m
[32m+[m[32m这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）[m
[32m+[m
[32m+[m[32m## 输入格式[m
[32m+[m
[32m+[m[32m第一行一个整数 $n$，表示班上人数。[m
[32m+[m
[32m+[m[32m接下来 $n$ 行，每行一个字符串表示其名字（互不相同，且只含小写字母，长度不超过 $50$）。[m
[32m+[m
[32m+[m[32m第 $n+2$ 行一个整数 $m$，表示教练报的名字个数。[m
[32m+[m
[32m+[m[32m接下来 $m$ 行，每行一个字符串表示教练报的名字（只含小写字母，且长度不超过 $50$）。[m
[32m+[m
[32m+[m[32m## 输出格式[m
[32m+[m
[32m+[m[32m对于每个教练报的名字，输出一行。[m
[32m+[m
[32m+[m[32m如果该名字正确且是第一次出现，输出 `OK`，如果该名字错误，输出 `WRONG`，如果该名字正确但不是第一次出现，输出 `REPEAT`。[m
[32m+[m
[32m+[m[32m## 输入输出样例 #1[m
[32m+[m
[32m+[m[32m### 输入 #1[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32m5[m[41m  [m
[32m+[m[32ma[m
[32m+[m[32mb[m
[32m+[m[32mc[m
[32m+[m[32mad[m
[32m+[m[32macd[m
[32m+[m[32m3[m
[32m+[m[32ma[m
[32m+[m[32ma[m
[32m+[m[32me[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 输出 #1[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32mOK[m
[32m+[m[32mREPEAT[m
[32m+[m[32mWRONG[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 说明/提示[m
[32m+[m
[32m+[m[32m- 对于 $40\%$ 的数据，$n\le 1000$，$m\le 2000$。[m
[32m+[m[32m- 对于 $70\%$ 的数据，$n\le 10^4$，$m\le 2\times 10^4$。[m
[32m+[m[32m- 对于 $100\%$ 的数据，$n\le 10^4$，$m≤10^5$。[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m$\text{upd 2022.7.30}$：新增加一组 Hack 数据。[m
[32m+[m
[32m+[m[32m## 相当简单的一道题:[m
[32m+[m[32m```cpp[m
[32m+[m[32m#include <bits/stdc++.h>[m
[32m+[m[32musing namespace std;[m
[32m+[m[32mint n, m;[m
[32m+[m[32munordered_map<string, int> mp;[m
[32m+[m[32mint main(void)[m
[32m+[m[32m{[m
[32m+[m[32m    ios::sync_with_stdio(false);[m
[32m+[m[32m    cin.tie(nullptr);[m
[32m+[m[32m    cin >> n;[m
[32m+[m[32m    for(int i = 0; i < n; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        string s;[m
[32m+[m[32m        cin >> s;[m
[32m+[m[32m        mp[s] = 1;[m
[32m+[m[32m    }[m
[32m+[m[32m    cin >> m;[m
[32m+[m[32m    for(int i = 0; i < m; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        string s;[m
[32m+[m[32m        cin >> s;[m
[32m+[m[32m        if(mp.find(s) == mp.end()) cout << "WRONG" << endl;[m
[32m+[m[32m        else if(mp[s] == 1)[m
[32m+[m[32m        {[m
[32m+[m[32m            cout << "OK" << endl;[m
[32m+[m[32m            mp[s] = 2;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if(mp[s] == 2) cout << "REPEAT" << endl;[m
[32m+[m[32m    }[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
\ No newline at end of file[m
[1mdiff --git "a/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P3375_KMP(\346\250\241\346\235\277).md" "b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P3375_KMP(\346\250\241\346\235\277).md"[m
[1mindex 597134a..7fd4060 100644[m
[1m--- "a/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P3375_KMP(\346\250\241\346\235\277).md"[m
[1m+++ "b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P3375_KMP(\346\250\241\346\235\277).md"[m
[36m@@ -52,4 +52,84 @@[m [mABA[m
 - Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。[m
 - Subtask 3（30 points）：无特殊约定。[m
 [m
[31m-对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。[m
\ No newline at end of file[m
[32m+[m[32m对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。[m
[32m+[m
[32m+[m[32m## 下面第一份是AI算法:[m
[32m+[m[32m```cpp[m
[32m+[m[32m#include <bits/stdc++.h>[m
[32m+[m[32musing namespace std;[m
[32m+[m
[32m+[m[32m// 构造 next 数组，next[i] 表示 s[0...i] 的最长相等前后缀长度[m
[32m+[m[32mvoid getNext(const string &s, vector<int> &next) {[m
[32m+[m[32m    int n = s.size();[m
[32m+[m[32m    next[0] = 0;[m
[32m+[m[32m    int j = 0;[m
[32m+[m[32m    for(int i = 1; i < n; i++) {[m
[32m+[m[32m        while(j > 0 && s[i] != s[j]) j = next[j-1];[m
[32m+[m[32m        if(s[i] == s[j]) j++;[m
[32m+[m[32m        next[i] = j;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// KMP 主体[m
[32m+[m[32mvoid kmp(const string &s1, const string &s2, const vector<int> &next) {[m
[32m+[m[32m    int n = s1.size(), m = s2.size();[m
[32m+[m[32m    int j = 0;[m
[32m+[m[32m    for(int i = 0; i < n; i++) {[m
[32m+[m[32m        while(j > 0 && s1[i] != s2[j]) j = next[j-1];[m
[32m+[m[32m        if(s1[i] == s2[j]) j++;[m
[32m+[m[32m        if(j == m) {[m
[32m+[m[32m            cout << i - m + 2 << endl; // 1-based[m
[32m+[m[32m            j = next[j-1];[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint main(void){[m
[32m+[m[32m    string s1, s2;[m
[32m+[m[32m    cin >> s1 >> s2;[m
[32m+[m[32m    vector<int> next(s2.length(), 0);[m
[32m+[m[32m    getNext(s2, next);[m
[32m+[m[32m    kmp(s1, s2, next);[m
[32m+[m[32m    for(int i = 0; i < next.size(); i++) cout << next[i] << " ";[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 我的代码,也过了[m
[32m+[m[32m```cpp[m
[32m+[m[32m#include <bits/stdc++.h>[m
[32m+[m[32musing namespace std;[m
[32m+[m[32mvoid nextval(const string &s, vector<int> &next);[m
[32m+[m[32mvoid kmp(const string &s1, const string &s2, vector<int> &next);[m
[32m+[m[32mint main(void){[m
[32m+[m[32m    string s1, s2;[m
[32m+[m[32m    cin >> s1 >> s2;[m
[32m+[m[32m    vector<int> next(s2.length() + 1, 0);[m
[32m+[m[32m    nextval(s2, next);[m
[32m+[m[32m    kmp(s1, s2, next);[m
[32m+[m[32m    for(int i = 1; i < next.size(); i++) cout << next[i] << " ";[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid nextval(const string &s, vector<int> &next){[m
[32m+[m[32m    int j = -1, i = 0;[m
[32m+[m[32m    next[0] = -1;[m
[32m+[m[32m    while(i < s.length())[m
[32m+[m[32m    {[m
[32m+[m[32m        while(j != -1 && s[i] != s[j]) j = next[j];[m
[32m+[m[32m        next[++i] = ++j;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m[32mvoid kmp(const string &s1, const string &s2, vector<int> &next){[m
[32m+[m[32m    int j = 0;[m
[32m+[m[32m    for(int i = 0; i < s1.length(); i++){[m
[32m+[m[32m        while(j > 0 && s1[i] != s2[j]) j = next[j];[m
[32m+[m[32m        if(s1[i] == s2[j]) j++;[m
[32m+[m[32m        if(j == s2.length()){[m
[32m+[m[32m            cout << i + 2 - j<< endl;[m
[32m+[m[32m            j = next[j];[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m[32m```[m
\ No newline at end of file[m
[1mdiff --git "a/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P4391_\346\227\240\351\231\220\344\274\240\346\222\255.md" "b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P4391_\346\227\240\351\231\220\344\274\240\346\222\255.md"[m
[1mnew file mode 100644[m
[1mindex 0000000..0551d26[m
[1m--- /dev/null[m
[1m+++ "b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/P4391_\346\227\240\351\231\220\344\274\240\346\222\255.md"[m
[36m@@ -0,0 +1,80 @@[m
[32m+[m[32m# P4391 [BalticOI 2009] Radio Transmission 无线传输[m
[32m+[m
[32m+[m[32m## 题目描述[m
[32m+[m
[32m+[m[32m给你一个字符串 $s_1$，它是由某个字符串 $s_2$ 不断自我连接形成的（保证至少重复 $2$ 次）。但是字符串 $s_2$ 是不确定的，现在只想知道它的最短长度是多少。[m
[32m+[m
[32m+[m[32m## 输入格式[m
[32m+[m
[32m+[m[32m第一行一个整数 $L$，表示给出字符串的长度。[m[41m [m
[32m+[m
[32m+[m[32m第二行给出字符串 $s_1$ 的一个子串，全由小写字母组成。[m
[32m+[m
[32m+[m[32m## 输出格式[m
[32m+[m
[32m+[m[32m仅一行，表示 $s_2$ 的最短长度。[m
[32m+[m
[32m+[m[32m## 输入输出样例 #1[m
[32m+[m
[32m+[m[32m### 输入 #1[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32m8[m
[32m+[m[32mcabcabca[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 输出 #1[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32m3[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 说明/提示[m
[32m+[m
[32m+[m[32m#### 样例输入输出 1 解释[m
[32m+[m[32m对于样例，我们可以利用 $\texttt{abc}$ 不断自我连接得到 $\texttt{abcabcabcabc}$，读入的 $\texttt{cabcabca}$，是它的子串。[m
[32m+[m
[32m+[m[32m#### 规模与约定[m
[32m+[m[32m对于全部的测试点，保证 $1\le L \le 10^6$。[m
[32m+[m
[32m+[m[32m## 也是相当简单的一道提高:[m
[32m+[m[32m```cpp[m
[32m+[m[32m#include <bits/stdc++.h>[m
[32m+[m[32musing namespace std;[m
[32m+[m[32mint n;[m
[32m+[m[32mstring s;[m
[32m+[m[32mint main(void)[m
[32m+[m[32m{[m
[32m+[m[32m    cin >> n >> s;[m[41m [m
[32m+[m[32m    for(int i = 1; i <= n; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        string t = s.substr(0, i);[m
[32m+[m[32m        bool flag = true;[m
[32m+[m[32m        for(int j = i; j < n; j += i)[m
[32m+[m[32m        {[m
[32m+[m[32m            if(j + i - 1 >= n)[m
[32m+[m[32m            {[m
[32m+[m[32m                if(s.substr(j) != t.substr(0, n - j))[m
[32m+[m[32m                {[m
[32m+[m[32m                    string temp1 = s.substr(j);[m
[32m+[m[32m                    string temp2 = t.substr(0, n - j + 1);[m
[32m+[m[32m                    flag = false;[m
[32m+[m[32m                    break;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            else if(s.substr(j, i) != t)[m
[32m+[m[32m            {[m
[32m+[m[32m                flag = false;[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            if(!flag) break;[m
[32m+[m[32m        }[m
[32m+[m[32m        if(flag)[m
[32m+[m[32m        {[m
[32m+[m[32m            cout << i << endl;[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m[41m               [m
[32m+[m[32m```[m
\ No newline at end of file[m
[1mdiff --git a/kislate_workshop/Problems/luogu/2025_spring/string_luogu/test_string.cpp b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/test_string.cpp[m
[1mindex 24afe3a..1d6a688 100644[m
[1m--- a/kislate_workshop/Problems/luogu/2025_spring/string_luogu/test_string.cpp[m
[1m+++ b/kislate_workshop/Problems/luogu/2025_spring/string_luogu/test_string.cpp[m
[36m@@ -1,48 +1,30 @@[m
 #include <bits/stdc++.h>[m
 using namespace std;[m
[31m-vector<int> _next;[m
[31m-void get_next(string T, int len)[m
[32m+[m[32mint n, m;[m
[32m+[m[32munordered_map<string, int> mp;[m
[32m+[m[32mint main(void)[m
 {[m
[31m-    int j = -1, i = 0;[m
[31m-    _next.resize(len + 1, 0);[m
[31m-    _next[0] = -1;[m
[31m-    // while(i < len)[m
[31m-    // {[m
[31m-    //     while(j != -1 && T[i] != T[j]) j = _next[j];[m
[31m-    //     _next[++i] = ++j;[m
[31m-    // }[m
[31m-    while(i < len)[m
[32m+[m[32m    ios::sync_with_stdio(false);[m
[32m+[m[32m    cin.tie(nullptr);[m
[32m+[m[32m    cin >> n;[m
[32m+[m[32m    for(int i = 0; i < n; i++)[m
     {[m
[31m-        while(j != -1 && T[i] != T[j]) j = _next[j];[m
[31m-        i++, j++;[m
[31m-        if(i < len && T[i] == T[j]) _next[i] = _next[j]; // 处理相同字符的情况[m
[31m-        else _next[i] = j; // 处理不同字符的情况[m
[32m+[m[32m        string s;[m
[32m+[m[32m        cin >> s;[m
[32m+[m[32m        mp[s] = 1;[m
     }[m
[31m-}[m
[31m-int main(void)[m
[31m-{[m
[31m-    string S, T;[m
[31m-    cin >> S >> T;[m
[31m-    int lens = (int)S.length(), lent = (int)T.length();[m
[31m-    get_next(T, lent);[m
[31m-    // KMP algorithm[m
[31m-    int k = 0, m = 0;[m
[31m-    vector<int> pos;[m
[31m-    while(k < lens)[m
[32m+[m[32m    cin >> m;[m
[32m+[m[32m    for(int i = 0; i < m; i++)[m
     {[m
[31m-        if(m == lent) // full match[m
[31m-        {[m
[31m-            pos.push_back(k - lent);[m
[31m-            m = _next[m]; // reset m to the next position in T[m
[31m-        }[m
[31m-        if(S[k] == T[m]) k++, m++; // single match success, increment k and m[m
[31m-        else[m
[32m+[m[32m        string s;[m
[32m+[m[32m        cin >> s;[m
[32m+[m[32m        if(mp.find(s) == mp.end()) cout << "WRONG" << endl;[m
[32m+[m[32m        else if(mp[s] == 1)[m
         {[m
[31m-            if(m == -1 || m== 0) k++;[m
[31m-            else m = _next[m]; // reset m to the next position in T[m
[32m+[m[32m            cout << "OK" << endl;[m
[32m+[m[32m            mp[s] = 2;[m
         }[m
[32m+[m[32m        else if(mp[s] == 2) cout << "REPEAT" << endl;[m
     }[m
[31m-    for(const int it : pos) cout << it + 1 << endl; // print the positions of matches[m
[31m-    for(int i = 1; i < lent + 1; i++) cout << ((_next[i] == -1) ? 0 : _next[i]) << " "; // print the string T[m
[31m-    return 0;   [m
[32m+[m[32m    return 0;[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/kislate_workshop/Problems/touge_c/data_structure_spring/erchashu/task_pro.cpp b/kislate_workshop/Problems/touge_c/data_structure_spring/erchashu/task_pro.cpp[m
[1mindex 9096331..5554ec4 100644[m
[1m--- a/kislate_workshop/Problems/touge_c/data_structure_spring/erchashu/task_pro.cpp[m
[1m+++ b/kislate_workshop/Problems/touge_c/data_structure_spring/erchashu/task_pro.cpp[m
[36m@@ -775,6 +775,8 @@[m [mint main(void) {[m
                     scanf("%s", filename);[m
                     if(LoadBiTreeFromFile(Trees.elem[pos-1].T, filename) == OK) {[m
                         printf("      加载二叉树成功！\n");[m
[32m+[m[32m                        printf("      二叉树 [%s] 的结构如下：\n", name);[m
[32m+[m[32m                        PrintTree(Trees.elem[pos-1].T);[m
                     } else {[m
                         printf("      加载二叉树失败！\n");[m
                     }[m
[1mdiff --git "a/kislate_workshop/Problems/touge_c/data_structure_spring/experiment/2024\347\272\247-\346\225\260\346\215\256\347\273\223\346\236\204\345\256\236\351\252\214\345\206\205\345\256\271\344\270\216\350\246\201\346\261\202\357\274\210\347\273\231\345\255\246\347\224\237\357\274\211/2024\347\272\247-\346\225\260\346\215\256\347\273\223\346\236\204\345\256\236\351\252\214\345\206\205\345\256\271\344\270\216\350\246\201\346\261\202\357\274\210\347\273\231\345\255\246\347\224\237\357\274\211/~$\347\273\223\346\236\204\345\256\236\351\252\214\344\273\273\345\212\241\344\271\246\357\274\2102024\347\272\247\357\274\211.docx" "b/kislate_workshop/Problems/touge_c/data_structure_spring/experiment/2024\347\272\247-\346\225\260\346\215\256\347\273\223\346\236\204\345\256\236\351\252\214\345\206\205\345\256\271\344\270\216\350\246\201\346\261\202\357\274\210\347\273\231\345\255\246\347\224\237\357\274\211/2024\347\272\247-\346\225\260\346\215\256\347\273\223\346\236\204\345\256\236\351\252\214\345\206\205\345\256\271\344\270\216\350\246\201\346\261\202\357\274\210\347\273\231\345\255\246\347\224\237\357\274\211/~$\347\273\223\346\236\204\345\256\236\351\252\214\344\273\273\345\212\241\344\271\246\357\274\2102024\347\272\247\357\274\211.docx"[m
[1mnew file mode 100644[m
[1mindex 0000000..b272f68[m
Binary files /dev/null and "b/kislate_workshop/Problems/touge_c/data_structure_spring/experiment/2024\347\272\247-\346\225\260\346\215\256\347\273\223\346\236\204\345\256\236\351\252\214\345\206\205\345\256\271\344\270\216\350\246\201\346\261\202\357\274\210\347\273\231\345\255\246\347\224\237\357\274\211/2024\347\272\247-\346\225\260\346\215\256\347\273\223\346\236\204\345\256\236\351\252\214\345\206\205\345\256\271\344\270\216\350\246\201\346\261\202\357\274\210\347\273\231\345\255\246\347\224\237\357\274\211/~$\347\273\223\346\236\204\345\256\236\351\252\214\344\273\273\345\212\241\344\271\246\357\274\2102024\347\272\247\357\274\211.docx" differ
[1mdiff --git a/kislate_workshop/Problems/touge_c/data_structure_spring/final_push_1/task_plus.cpp b/kislate_workshop/Problems/touge_c/data_structure_spring/final_push_1/task_plus.cpp[m
[1mindex 8ee40bd..12bb370 100644[m
[1m--- a/kislate_workshop/Problems/touge_c/data_structure_spring/final_push_1/task_plus.cpp[m
[1m+++ b/kislate_workshop/Problems/touge_c/data_structure_spring/final_push_1/task_plus.cpp[m
[36m@@ -2,6 +2,7 @@[m
 #include <stdlib.h>[m
 #include <string.h>[m
 #include <malloc.h>[m
[32m+[m[32m#include <bits/stdc++.h>[m
 #include <windows.h> [m
 [m
 #define TRUE 1[m
[36m@@ -103,17 +104,36 @@[m [mint MaxSubArray(SqList L) {[m
 }[m
 // 附加功能2：和为K的子数组个数[m
 int SubArrayNum(SqList L, int k) {[m
[31m-    int count = 0;[m
[31m-    // O(n^2)的暴力解法[m
[32m+[m[32m    int count = 0, sum = 0;[m
[32m+[m[32m    std::unordered_map<int, int> mp;[m
[32m+[m[32m    mp[0] = 1;[m
     for(int i = 0; i < L.length; i++) {[m
[31m-        int sum = 0;[m
[31m-        for(int j = i; j < L.length; j++) {[m
[31m-            sum += L.elem[j];[m
[31m-            if(sum == k) count++;[m
[31m-        }[m
[32m+[m[32m        sum += L.elem[i];[m
[32m+[m[32m        if(mp.count(sum - k)) count += mp[sum - k];[m
[32m+[m[32m        mp[sum]++;[m
     }[m
     return count;[m
 }[m
[32m+[m
[32m+[m[32m// 无stl版本的和为K的子数组个数[m
[32m+[m[32m// // 附加功能2：和为K的子数组个数（C语言实现，前缀和+数组哈希，适合小范围）[m
[32m+[m[32m// int SubArrayNum(SqList L, int k) {[m
[32m+[m[32m//     int count = 0, sum = 0;[m
[32m+[m[32m//     // 假设前缀和范围在 [-100000, 100000][m
[32m+[m[32m//     // 需要开 200001 大小的数组，偏移量为 100000[m
[32m+[m[32m//     static int mp[200001] = {0};[m
[32m+[m[32m//     int offset = 100000;[m
[32m+[m[32m//     for(int i = 0; i < 200001; i++) mp[i] = 0;[m
[32m+[m[32m//     mp[offset] = 1; // sum=0 出现1次[m
[32m+[m[32m//     for(int i = 0; i < L.length; i++) {[m
[32m+[m[32m//         sum += L.elem[i];[m
[32m+[m[32m//         int idx = sum - k + offset;[m
[32m+[m[32m//         if(idx >= 0 && idx < 200001) count += mp[idx];[m
[32m+[m[32m//         mp[sum + offset]++;[m
[32m+[m[32m//     }[m
[32m+[m[32m//     return count;[m
[32m+[m[32m// }[m
[32m+[m
 // 附加功能3：顺序表排序[m
 void sortList(SqList &L) {[m
     if(L.elem == NULL) return; // 线性表不存在[m
[36m@@ -360,6 +380,8 @@[m [mvoid singleListControl(SqList &L) {[m
             case 16:[m
                 sortList(L);[m
                 printf("      排序完成！\n");[m
[32m+[m[32m                printf("      排序后的线性表为：\n");[m
[32m+[m[32m                ListTrabverse(L);[m
                 getchar();[m
                 printf("      按任意键继续...\n");[m
                 getchar();[m
[1mdiff --git a/kislate_workshop/algotithm/data_struct/KMP.cpp b/kislate_workshop/algotithm/data_struct/KMP.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..d6e8383[m
[1m--- /dev/null[m
[1m+++ b/kislate_workshop/algotithm/data_struct/KMP.cpp[m
[36m@@ -0,0 +1,91 @@[m
[32m+[m[32m#include "stdio.h"[m
[32m+[m[32m#include "stdlib.h"[m
[32m+[m[32m#include "string.h"[m
[32m+[m[32mtypedef struct {[m
[32m+[m	[32mchar *ch;[m
[32m+[m[32m   int length;[m
[32m+[m[32m} HString;[m
[32m+[m[32mvoid Replace(HString &S,HString T,HString V)[m
[32m+[m[32m//[m
[32m+[m[32m{[m
[32m+[m[32m/************** begin *****************/[m
[32m+[m[32m// kmp算法求解[m
[32m+[m[32m// 求next数组;[m
[32m+[m[32mint *next = (int *)malloc((T.length+1)*sizeof(int));[m
[32m+[m[32mnext[0] = -1;[m
[32m+[m[32mint j = -1, i = 0;[m
[32m+[m[32mwhile(i < T.length)[m
[32m+[m[32m{[m
[32m+[m[32m    while(j != -1 && T.ch[i] != T.ch[j]) j = next[j];[m
[32m+[m[32m    next[++i] = ++j;[m
[32m+[m[32m}[m
[32m+[m[32m/*for(int i = 0; i < T.length; i++)[m
[32m+[m[32m    printf("%d ", next[i]);// 非常完美的next数组[m
[32m+[m[32m*/[m
[32m+[m[32m// kmp算法匹配[m
[32m+[m[32mint k = 0, m = 0, cnt = 0;[m
[32m+[m[32m// 存储新串的数组[m
[32m+[m[32mchar *newStr = (char *)malloc(1000* sizeof(char));[m
[32m+[m[32mwhile(k < S.length)[m
[32m+[m[32m{[m
[32m+[m[32m    if(m == T.length) // 全匹配成功[m
[32m+[m[32m    {[m
[32m+[m[32m        for(int i = 0; i < V.length; i++) newStr[cnt++] = V.ch[i];[m
[32m+[m[32m        m = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m    if(S.ch[k] == T.ch[m]) k++, m++; // 单匹配成功, 匹配数加一,继续匹配下一个字符[m
[32m+[m[32m    else{[m
[32m+[m[32m        if(m == 0) newStr[cnt++] = S.ch[k++]; // 单匹配失败, k加一, m不变[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            // 把之前没加的给加上去[m
[32m+[m[32m            for(int i = 0; i < (m - next[m]); i++) newStr[cnt++] = S.ch[k - m + i];[m
[32m+[m[32m            m = next[m];[m
[32m+[m[32m            if(m == -1) m = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    // if(k == S.length) // 未能正确处理结束时如果刚好有需要处理的字符串的情况[m
[32m+[m[32m    // {[m
[32m+[m[32m    //     for(int i = k - m; i < S.length; i++) newStr[cnt++] = S.ch[i]; // 把剩下的字符加上去[m
[32m+[m[32m    //     break;[m
[32m+[m[32m    // }[m
[32m+[m[32m    if(k == S.length)[m
[32m+[m[32m    {[m
[32m+[m[32m        if(m == T.length)[m[41m [m
[32m+[m[32m        {[m
[32m+[m[32m            for(int i = 0; i < V.length; i++) newStr[cnt++] = V.ch[i];[m
[32m+[m[32m            m = 0;[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            for(int i = k - m; i < S.length; i++) newStr[cnt++] = S.ch[i];[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m[32mfree(next);[m
[32m+[m[32mfree(S.ch);[m
[32m+[m[32mS.ch = newStr;[m
[32m+[m[32mS.length = cnt;[m
[32m+[m[32m/**************  end  *****************/[m
[32m+[m[32m}[m
[32m+[m[32mint main()[m
[32m+[m[32m{[m
[32m+[m[32mHString S[3];[m
[32m+[m[32mchar buf[100],i,j;[m
[32m+[m[32mfor(i=0;i<3;i++)[m
[32m+[m[32m{[m
[32m+[m	[32mfgets(buf,100,stdin);[m
[32m+[m	[32mS[i].length=strlen(buf)-1;  //-1是去掉回车符号[m
[32m+[m	[32mS[i].ch=(char *)malloc(S[i].length);[m
[32m+[m	[32mfor(j=0;j<S[i].length; j++)[m
[32m+[m		[32mS[i].ch[j]=*(buf+j);[m
[32m+[m[32m}[m
[32m+[m[32mReplace(S[0],S[1],S[2]);[m
[32m+[m[32mprintf("S的长度：%d\n",S[0].length);[m
[32m+[m[32mfor(i=0;i<S[0].length;i++)[m
[32m+[m	[32mputchar(S[0].ch[i]);[m
[32m+[m[32mreturn 1;[m
[32m+[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/kislate_workshop/stream.py b/kislate_workshop/stream.py[m
[1mnew file mode 100644[m
[1mindex 0000000..80e4484[m
[1m--- /dev/null[m
[1m+++ b/kislate_workshop/stream.py[m
[36m@@ -0,0 +1,49 @@[m
[32m+[m[32mfrom graphviz import Digraph[m
[32m+[m
[32m+[m[32m# 创建流程图对象[m
[32m+[m[32mdot = Digraph(name="SubArrayNum_Flowchart", comment='SubArrayNum 流程图', format="png")[m
[32m+[m[32mdot.graph_attr['rankdir'] = 'TB'  # Top to Bottom[m
[32m+[m[32mdot.node_attr.update(shape='rectangle', style='rounded')[m
[32m+[m
[32m+[m[32m# 开始节点[m
[32m+[m[32mdot.node('start', '开始', shape='ellipse')[m
[32m+[m
[32m+[m[32m# 初始化部分[m
[32m+[m[32mdot.node('init_count_sum', '初始化 count = 0, sum = 0')[m
[32m+[m[32mdot.node('init_offset', '设置偏移量 offset = 100000')[m
[32m+[m[32mdot.node('init_mp', '定义哈希数组 mp[200001]，全部置为 0')[m
[32m+[m[32mdot.node('mp_offset_1', 'mp[offset] = 1 （表示前缀和为 0 的情况出现一次）')[m
[32m+[m
[32m+[m[32m# 循环部分[m
[32m+[m[32mdot.node('loop_start', 'i = 0')[m
[32m+[m[32mdot.node('loop_condition', 'i < L.length?', shape='diamond')[m
[32m+[m[32mdot.node('sum_add_elem', 'sum += L.elem[i]')[m
[32m+[m[32mdot.node('calc_idx', 'idx = sum - k + offset')[m
[32m+[m[32mdot.node('check_idx', 'idx ∈ [0, 200001)?', shape='diamond')[m
[32m+[m[32mdot.node('count_add_mp', 'count += mp[idx]')[m
[32m+[m[32mdot.node('mp_increment', 'mp[sum + offset]++')[m
[32m+[m[32mdot.node('i_increment', 'i++')[m
[32m+[m[32mdot.node('end', '返回 count', shape='ellipse')[m
[32m+[m
[32m+[m[32m# 连接节点[m
[32m+[m[32mdot.edge('start', 'init_count_sum')[m
[32m+[m[32mdot.edge('init_count_sum', 'init_offset')[m
[32m+[m[32mdot.edge('init_offset', 'init_mp')[m
[32m+[m[32mdot.edge('init_mp', 'mp_offset_1')[m
[32m+[m[32mdot.edge('mp_offset_1', 'loop_start')[m
[32m+[m[32mdot.edge('loop_start', 'loop_condition')[m
[32m+[m
[32m+[m[32m# 循环判断内的连接[m
[32m+[m[32mdot.edge('loop_condition', 'sum_add_elem', label='是')[m
[32m+[m[32mdot.edge('sum_add_elem', 'calc_idx')[m
[32m+[m[32mdot.edge('calc_idx', 'check_idx')[m
[32m+[m[32mdot.edge('check_idx', 'count_add_mp', label='是')[m
[32m+[m[32mdot.edge('count_add_mp', 'mp_increment')[m
[32m+[m[32mdot.edge('mp_increment', 'i_increment')[m
[32m+[m[32mdot.edge('i_increment', 'loop_condition')[m
[32m+[m[32mdot.edge('check_idx', 'mp_increment', label='否')[m
[32m+[m[32mdot.edge('loop_condition', 'end', label='否')[m
[32m+[m
[32m+[m[32m# 保存并渲染图像[m
[32m+[m[32mdot.render(filename='subarraynum_flowchart', view=True)[m
[32m+[m[32mprint("✅ 流程图已生成：subarraynum_flowchart.png")[m
\ No newline at end of file[m
[1mdiff --git a/kislate_workshop/subarraynum_flowchart b/kislate_workshop/subarraynum_flowchart[m
[1mnew file mode 100644[m
[1mindex 0000000..5c11787[m
[1m--- /dev/null[m
[1m+++ b/kislate_workshop/subarraynum_flowchart[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32m// SubArrayNum 流程图[m
[32m+[m[32mdigraph SubArrayNum_Flowchart {[m
[32m+[m	[32mgraph [rankdir=TB][m
[32m+[m	[32mnode [shape=rectangle style=rounded][m
[32m+[m	[32mstart [label="开始" shape=ellipse][m
[32m+[m	[32minit_count_sum [label="初始化 count = 0, sum = 0"][m
[32m+[m	[32minit_offset [label="设置偏移量 offset = 100000"][m
[32m+[m	[32minit_mp [label="定义哈希数组 mp[200001]，全部置为 0"][m
[32m+[m	[32mmp_offset_1 [label="mp[offset] = 1 （表示前缀和为 0 的情况出现一次）"][m
[32m+[m	[32mloop_start [label="i = 0"][m
[32m+[m	[32mloop_condition [label="i < L.length?" shape=diamond][m
[32m+[m	[32msum_add_elem [label="sum += L.elem[i]"][m
[32m+[m	[32mcalc_idx [label="idx = sum - k + offset"][m
[32m+[m	[32mcheck_idx [label="idx ∈ [0, 200001)?" shape=diamond][m
[32m+[m	[32mcount_add_mp [label="count += mp[idx]"][m
[32m+[m	[32mmp_increment [label="mp[sum + offset]++"][m
[32m+[m	[32mi_increment [label="i++"][m
[32m+[m	[32mend [label="返回 count" shape=ellipse][m
[32m+[m	[32mstart -> init_count_sum[m
[32m+[m	[32minit_count_sum -> init_offset[m
[32m+[m	[32minit_offset -> init_mp[m
[32m+[m	[32minit_mp -> mp_offset_1[m
[32m+[m	[32mmp_offset_1 -> loop_start[m
[32m+[m	[32mloop_start -> loop_condition[m
[32m+[m	[32mloop_condition -> sum_add_elem [label="是"][m
[32m+[m	[32msum_add_elem -> calc_idx[m
[32m+[m	[32mcalc_idx -> check_idx[m
[32m+[m	[32mcheck_idx -> count_add_mp [label="是"][m
[32m+[m	[32mcount_add_mp -> mp_increment[m
[32m+[m	[32mmp_increment -> i_increment[m
[32m+[m	[32mi_increment -> loop_condition[m
[32m+[m	[32mcheck_idx -> mp_increment [label="否"][m
[32m+[m	[32mloop_condition -> end [label="否"][m
[32m+[m[32m}[m
[1mdiff --git a/subarraynum_flowchart b/subarraynum_flowchart[m
[1mnew file mode 100644[m
[1mindex 0000000..5c11787[m
[1m--- /dev/null[m
[1m+++ b/subarraynum_flowchart[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32m// SubArrayNum 流程图[m
[32m+[m[32mdigraph SubArrayNum_Flowchart {[m
[32m+[m	[32mgraph [rankdir=TB][m
[32m+[m	[32mnode [shape=rectangle style=rounded][m
[32m+[m	[32mstart [label="开始" shape=ellipse][m
[32m+[m	[32minit_count_sum [label="初始化 count = 0, sum = 0"][m
[32m+[m	[32minit_offset [label="设置偏移量 offset = 100000"][m
[32m+[m	[32minit_mp [label="定义哈希数组 mp[200001]，全部置为 0"][m
[32m+[m	[32mmp_offset_1 [label="mp[offset] = 1 （表示前缀和为 0 的情况出现一次）"][m
[32m+[m	[32mloop_start [label="i = 0"][m
[32m+[m	[32mloop_condition [label="i < L.length?" shape=diamond][m
[32m+[m	[32msum_add_elem [label="sum += L.elem[i]"][m
[32m+[m	[32mcalc_idx [label="idx = sum - k + offset"][m
[32m+[m	[32mcheck_idx [label="idx ∈ [0, 200001)?" shape=diamond][m
[32m+[m	[32mcount_add_mp [label="count += mp[idx]"][m
[32m+[m	[32mmp_increment [label="mp[sum + offset]++"][m
[32m+[m	[32mi_increment [label="i++"][m
[32m+[m	[32mend [label="返回 count" shape=ellipse][m
[32m+[m	[32mstart -> init_count_sum[m
[32m+[m	[32minit_count_sum -> init_offset[m
[32m+[m	[32minit_offset -> init_mp[m
[32m+[m	[32minit_mp -> mp_offset_1[m
[32m+[m	[32mmp_offset_1 -> loop_start[m
[32m+[m	[32mloop_start -> loop_condition[m
[32m+[m	[32mloop_condition -> sum_add_elem [label="是"][m
[32m+[m	[32msum_add_elem -> calc_idx[m
[32m+[m	[32mcalc_idx -> check_idx[m
[32m+[m	[32mcheck_idx -> count_add_mp [label="是"][m
[32m+[m	[32mcount_add_mp -> mp_increment[m
[32m+[m	[32mmp_increment -> i_increment[m
[32m+[m	[32mi_increment -> loop_condition[m
[32m+[m	[32mcheck_idx -> mp_increment [label="否"][m
[32m+[m	[32mloop_condition -> end [label="否"][m
[32m+[m[32m}[m
[1mdiff --git a/test.md b/test.md[m
[1mnew file mode 100644[m
[1mindex 0000000..ff527cd[m
[1m--- /dev/null[m
[1m+++ b/test.md[m
[36m@@ -0,0 +1,304 @@[m
[32m+[m[32m# 顺序表管理系统测试样例[m
[32m+[m
[32m+[m[32m## 1. 多表管理功能[m
[32m+[m
[32m+[m[32m### 1.1 新建线性表[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m1[m
[32m+[m[32mlistA[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m新建线性表成功！[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 1.2 新建重名线性表[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m1[m
[32m+[m[32mlistA[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m线性表名重复！[m
[32m+[m[32m新建线性表失败！[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 1.3 新建多个线性表[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m1[m
[32m+[m[32mlistB[m
[32m+[m[32m1[m
[32m+[m[32mlistC[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m新建线性表成功！[m
[32m+[m[32m新建线性表成功！[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 1.4 打印所有线性表名[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m3[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m当前已有线性表数量：3[m
[32m+[m[32m1. listA[m
[32m+[m[32m2. listB[m
[32m+[m[32m3. listC[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 1.5 删除线性表[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m2[m
[32m+[m[32mlistB[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m删除线性表成功！[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 1.6 删除不存在的线性表[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m2[m
[32m+[m[32mlistX[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m删除线性表失败（不存在）！[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 2. 单表操作功能（以listA为例）[m
[32m+[m
[32m+[m[32m### 2.1 进入线性表[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m4[m
[32m+[m[32mlistA[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.2 初始化线性表[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m1[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m线性表创建成功！[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.3 插入元素[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m10[m
[32m+[m[32m1 5[m
[32m+[m[32m10[m
[32m+[m[32m2 3[m
[32m+[m[32m10[m
[32m+[m[32m3 7[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m插入成功！[m
[32m+[m[32m插入成功！[m
[32m+[m[32m插入成功！[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.4 遍历线性表[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m12[m
[32m+[m[32m0[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m线性表元素为：[m
[32m+[m[32m5 3 7[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.5 获取第2个元素[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m6[m
[32m+[m[32m2[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m第2个元素为：3[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.6 查找元素位置[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m7[m
[32m+[m[32m7[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m元素7的位置为：3[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.7 获取前驱/后继[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m8[m
[32m+[m[32m3[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m元素3的前驱为：5[m
[32m+[m[32m```[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m9[m
[32m+[m[32m3[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m元素3的后继为：7[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.8 删除第2个元素[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m11[m
[32m+[m[32m2[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m删除的元素为：3[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.9 清空线性表[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m3[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m线性表清空成功！[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.10 快速插入[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m13[m
[32m+[m[32m10 20 30 x[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m插入成功！当前线性表长度为:1[m
[32m+[m[32m插入成功！当前线性表长度为:2[m
[32m+[m[32m插入成功！当前线性表长度为:3[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 2.11 详细遍历[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m12[m
[32m+[m[32m1[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m线性表的长度为3：[m
[32m+[m[32m线性表元素为：[m
[32m+[m[32m1:10 2:20 3:30[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 3. 附加功能[m
[32m+[m
[32m+[m[32m### 3.1 最大连续子数组和[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m14[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m最大连续子数组和为：60[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 3.2 和为K的子数组个数[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m15[m
[32m+[m[32m30[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m和为30的连续子数组个数为：1[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 3.3 顺序表排序[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m16[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m排序完成！[m
[32m+[m[32m```[m
[32m+[m[32m再次遍历：[m
[32m+[m[32m```[m
[32m+[m[32m12[m
[32m+[m[32m0[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m10 20 30[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 4. 文件保存与加载[m
[32m+[m
[32m+[m[32m### 4.1 保存线性表到文件[m
[32m+[m[32m主菜单输入：[m
[32m+[m[32m```[m
[32m+[m[32m5[m
[32m+[m[32mlistA[m
[32m+[m[32mlistA.dat[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m已保存到文件：listA.dat[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 4.2 从文件加载到线性表[m
[32m+[m[32m主菜单输入：[m
[32m+[m[32m```[m
[32m+[m[32m6[m
[32m+[m[32mlistC[m
[32m+[m[32mlistA.dat[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m已从文件加载线性表：listA.dat[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### 4.3 打印全部线性表[m
[32m+[m[32m主菜单输入：[m
[32m+[m[32m```[m
[32m+[m[32m7[m
[32m+[m[32m1[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m表名：listA[m
[32m+[m[32m10 20 30[m
[32m+[m[32m表名：listC[m
[32m+[m[32m10 20 30[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## 5. 退出系统[m
[32m+[m[32m输入：[m
[32m+[m[32m```[m
[32m+[m[32m0[m
[32m+[m[32m```[m
[32m+[m[32m输出：[m
[32m+[m[32m```[m
[32m+[m[32m再见！[m
[32m+[m[32m```[m
