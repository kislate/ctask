
---

# 🧮 枚举 Bitmask 所有非空子集的方法

在状态压缩动态规划（Bitmask DP）中，我们经常需要枚举一个集合的所有子集来进行状态转移。下面是一种非常经典且高效的位运算技巧。

---

## 🔁 取子集的代码模板

```cpp
for(ull j = rest; j; j = (j - 1) & rest)
{
    // j 是 rest 的一个非空子集
    if (!isValid(j)) continue;  // 判断是否合法
    ull next = i | j;           // 新状态
    dp[next] = min(dp[next], dp[i] + cost(j));
}
```

---

## 📌 参数说明

| 变量 | 含义 |
|------|------|
| `rest` | 当前剩余可选元素的集合（bitmask 表示） |
| `j` | 枚举出的 `rest` 的一个非空子集 |
| `i` | 当前状态 |
| `next` | 转移后的新状态 |
| `isValid(j)` | 判断子集 `j` 是否满足题目条件（如总重量 ≤ W） |
| `cost(j)` | 子集 `j` 对应的代价（如该组最大时间） |

---

## 🧠 工作原理

- `(j - 1) & rest`：生成比当前 `j` 更小的下一个子集
- 按照从大到小的顺序枚举所有非空子集
- 保证只访问属于 `rest` 的那些 bit 位

---

## ✅ 示例

设 `rest = 0b1010`（即第 1 和第 3 位为 1），则会依次枚举出：

```
0b1010 → 0b1000 → 0b0010
```

这些都是 `rest` 的非空子集。

---

## ⏱️ 时间复杂度

- 枚举一个 bitmask 的所有子集的时间为 $ O(2^k) $，其中 `k` 是 bitmask 中 `1` 的个数

---
