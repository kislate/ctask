
---

# 🧩 题目解析：「SCOI2005」互不侵犯

## 🔹题目描述

在一个 $ N \times N $ 的棋盘中放置 $ K $ 个国王（King），使得它们互相不能攻击。国王可以攻击周围 8 个方向的格子。

求这样的合法摆放方案数。

### 输入格式：
- 第一行两个整数 $ N $ 和 $ K $

### 输出格式：
- 一个整数，表示所有合法的摆法总数

### 数据范围：
- $ 1 \leq N \leq 9 $
- $ 1 \leq K \leq N^2 $

---

## 💡解题思路：状压动态规划（State Compression DP）

由于 $ N \leq 9 $，所以我们可以使用 **状态压缩动态规划（状压 DP）** 来解决这个问题。

每一行的状态可以用一个整数来表示，其中每一位表示该列是否放置国王（0 表示不放，1 表示放）。例如，`100101` 表示第 0、2、5 列放置了国王。

### 状态设计：

我们定义以下变量：

- `sit[j]`：第 j 个合法状态的二进制表示
- `sta[j]`：第 j 个状态中放了多少个国王（即 sit[j] 中 1 的个数）
- `f[i][j][l]`：前 i 行，第 i 行的状态是第 j 个合法状态，总共已经放置 l 个国王时的方案数

---

## ✅算法步骤详解

### Step 1: 预处理所有合法的一行状态

使用 DFS 枚举出所有一行内不会相邻的国王摆放方式。

```cpp
void dfs(int x, int num, int cur) {
  if (cur >= n) {  // 当前行构造完成
    sit[++cnt] = x;   // 存储当前合法状态
    sta[cnt] = num;   // 记录国王数量
    return;
  }
  dfs(x, num, cur + 1);               // 当前列不放国王
  dfs(x + (1 << cur), num + 1, cur + 2);  // 当前列放国王，跳过下一列避免冲突
}
```

### Step 2: 初始化第一行的状态

```cpp
for (int j = 1; j <= cnt; j++)
  f[1][j][sta[j]] = 1;  // 第一行只有当前状态的国王数量为 sta[j]
```

### Step 3: 动态规划转移

枚举每一行、当前行状态和上一行状态，判断是否兼容后进行状态转移：

```cpp
bool compatible(int j, int x) {
  if (sit[j] & sit[x]) return false;            // 正上方冲突
  if ((sit[j] << 1) & sit[x]) return false;     // 左上方冲突
  if (sit[j] & (sit[x] << 1)) return false;     // 右上方冲突
  return true;
}
```

主循环如下：

```cpp
for (int i = 2; i <= n; i++)                  // 枚举行数
  for (int j = 1; j <= cnt; j++)              // 当前行状态
    for (int x = 1; x <= cnt; x++) {          // 上一行状态
      if (!compatible(j, x)) continue;        // 排除不合法转移
      for (int l = sta[j]; l <= k; l++)       // 放置国王总数
        f[i][j][l] += f[i - 1][x][l - sta[j]];
    }
```

### Step 4: 统计最终答案

```cpp
long long ans = 0;
for (int i = 1; i <= cnt; i++)
  ans += f[n][i][k];  // 最后一行总共有 k 个国王的所有合法状态之和
cout << ans << endl;
```

---

## 📁完整 C++ 实现代码（含详细注释）

```cpp
#include <algorithm>
#include <iostream>
using namespace std;

// sit[j]: 第 j 个合法状态的二进制表示
// sta[j]: 第 j 个状态中放了多少个国王
long long sta[2005], sit[2005];
// f[i][j][l]: 前 i 行，第 i 行状态为 j，共放 l 个国王的方案数
long long f[15][2005][105];

int n, k, cnt;  // cnt 用于记录合法状态的数量

// 深度优先搜索生成所有合法的一行状态
void dfs(int x, int num, int cur) {
  if (cur >= n) {  // 一行构造完成
    sit[++cnt] = x;    // 存储状态
    sta[cnt] = num;    // 统计国王数量
    return;
  }
  dfs(x, num, cur + 1);                 // 当前列不放国王
  dfs(x + (1 << cur), num + 1, cur + 2);  // 当前列放国王，跳过下一列
}

// 判断上下两行状态是否冲突
bool compatible(int j, int x) {
  if (sit[j] & sit[x]) return false;             // 正上方冲突
  if ((sit[j] << 1) & sit[x]) return false;      // 左上方冲突
  if (sit[j] & (sit[x] << 1)) return false;      // 右上方冲突
  return true;
}

int main() {
  cin >> n >> k;

  dfs(0, 0, 0);  // 预处理所有合法状态

  // 初始化第一行
  for (int j = 1; j <= cnt; j++)
    f[1][j][sta[j]] = 1;

  // 动态规划转移
  for (int i = 2; i <= n; i++)                  // 枚举行数
    for (int j = 1; j <= cnt; j++)              // 当前行状态
      for (int x = 1; x <= cnt; x++) {          // 上一行状态
        if (!compatible(j, x)) continue;        // 如果冲突则跳过
        for (int l = sta[j]; l <= k; l++)       // 枚举总国王数
          f[i][j][l] += f[i - 1][x][l - sta[j]];  // 转移方程
      }

  // 统计最终答案
  long long ans = 0;
  for (int i = 1; i <= cnt; i++)
    ans += f[n][i][k];  // 所有最后一行且总共有 k 个国王的方案数之和

  cout << ans << endl;

  return 0;
}
```

---

## 🧠总结

| 技术点 | 说明 |
|--------|------|
| **状态压缩** | 使用二进制整数表示每行的国王分布 |
| **DFS预处理** | 提前找出所有合法状态，减少无效枚举 |
| **兼容性判断** | 检查上下行之间是否会有攻击情况 |
| **DP优化** | 使用三维数组进行状态转移，记录国王数量 |
| **时间复杂度** | 大约为 $ O(N \cdot C^2 \cdot K) $，其中 C 是合法状态数（最多几百） |

---

## 📌补充建议

- 可以尝试用滚动数组优化空间。
- 对于较大的 `k`，可以在转移时做剪枝。
- 若想拓展思路，可尝试类似题目如 **炮兵阵地**、**玉米田** 等状压 DP 典型题。

---

## 🧮 变量定义回顾

```cpp
long long sta[2005], sit[2005];  // 状态数组
int n, k, cnt;                    // cnt：合法状态的数量（计数器）
```

- `sit[]`：存储每一行的合法状态（二进制整数表示）
- `sta[]`：对应每个状态中放了多少个国王（即该二进制数中 1 的个数）
- `cnt`：每生成一个合法状态就递增一次，最终表示总共有多少种合法的一行国王摆放方式

---

## 🔍 `cnt` 的初始化过程（DFS 预处理）

```cpp
void dfs(int x, int num, int cur) {
  if (cur >= n) {                  // 当前行构造完成
    sit[++cnt] = x;                // 存储当前状态
    sta[cnt] = num;                // 存储国王数量
    return;
  }
  dfs(x, num, cur + 1);            // 不放国王
  dfs(x + (1 << cur), num + 1, cur + 2);  // 放国王，跳过下一列
}
```

### ✅举例说明：

假设 `n=3`，棋盘有 3 列。

DFS 枚举所有不相邻的国王放置方式，例如：

| 状态编号 | 二进制表示 | 国王数量 | 合法？ |
|----------|-------------|-----------|--------|
| 1        | 000         | 0         | ✅     |
| 2        | 001         | 1         | ✅     |
| 3        | 010         | 1         | ✅     |
| 4        | 100         | 1         | ✅     |
| 5        | 101         | 2         | ✅     |

其中：
- `sit[1] = 0b000 = 0`
- `sit[2] = 0b001 = 1`
- `sit[3] = 0b010 = 2`
- ...
- `sta[5] = 2`

所以，**`cnt` 最终的值是这些合法状态的总数**。

---

## 📌 为什么后面用 `cnt` 做终止条件？

在主函数中有如下结构：

```cpp
for (int j = 1; j <= cnt; j++) { ... }
```

### 这是因为：

- `j` 表示“第 j 个合法状态”
- 我们只关心这些合法的状态，因为非法状态（比如相邻两个位置都放国王）已经被 DFS 排除在外了。
- 所以我们只需要从 `1` 到 `cnt` 枚举所有合法状态即可，不需要遍历所有 $ 2^n $ 种可能。

### ⏱️ 效率提升：

如果不预处理，一行最多有 $ 2^n $ 种状态（指数级），但通过 DFS 预处理后，合法状态数大大减少（特别是当 n 较大时），可以显著提高效率。

---

## 🧠 总结

| 变量 | 含义 |
|------|------|
| `cnt` | 合法状态的总数（由 DFS 枚举得到） |
| `sit[j]` | 第 j 个合法状态的二进制表示 |
| `sta[j]` | 第 j 个状态中放了多少个国王 |
| `f[i][j][l]` | 前 i 行、第 i 行为状态 j、共放 l 个国王时的方案数 |

> **为什么要用 `cnt` 作为终止条件？**
>
> 因为我们只处理合法状态，而 `cnt` 正好记录了这些合法状态的总数，所以所有后续的枚举都只需到 `cnt` 即可。

---
