
# Floyd-Warshall 算法详解

## 1. 算法概述

Floyd-Warshall 算法是一种经典的**动态规划算法**，用于求解**带权有向图中所有顶点对之间的最短路径**。该算法可以处理含有**负权重边**的情况（但不能处理包含**负权重环路**的图）。

与其他最短路径算法不同的是，Floyd-Warshall 直接计算出任意两点之间的最短路径，而非从单一源点出发。

---

## 2. 算法原理

设图 $ G = (V, E) $，其中 $ V = \{1, 2, \dots, n\} $ 是顶点集合，$ w(i, j) $ 表示边 $ (i, j) $ 的权重。

定义状态转移函数：

$$
D_{ij}^{(k)} = \min(D_{ij}^{(k-1)}, D_{ik}^{(k-1)} + D_{kj}^{(k-1)})
$$

其中：
- $ D_{ij}^{(k)} $：表示从顶点 $ i $ 到顶点 $ j $，**中间节点只能是前 $ k $ 个节点**时的最短路径长度。
- 初始条件：$ D_{ij}^{(0)} = w(i, j) $，若无边则为无穷大 $ \infty $，且 $ D_{ii}^{(0)} = 0 $。

最终结果：$ D_{ij}^{(n)} $ 即为从 $ i $ 到 $ j $ 的最短路径长度。

---

## 3. 伪代码实现（C++ 风格）

```cpp
const int INF = 1e9; // 表示无穷大

void floydWarshall(int n, vector<vector<int>>& dist) {
    // dist[i][j] 初始化为边的权重，若无边则为 INF，dist[i][i] = 0

    for (int k = 0; k < n; ++k) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}
```

> ⚠️ 注意：在实际实现中，输入矩阵 `dist` 应提前初始化为邻接矩阵形式。

---

## 4. 路径重建（可选）

如果需要重建最短路径，可以维护一个 `next` 矩阵来记录路径：

```cpp
vector<vector<int>> next(n, vector<int>(n, -1));

// 在初始化时设置 next[i][j] = j 如果存在边 i -> j

// 更新时：
if (dist[i][k] + dist[k][j] < dist[i][j]) {
    dist[i][j] = dist[i][k] + dist[k][j];
    next[i][j] = next[i][k]; // 记录路径
}

// 获取路径函数
vector<int> reconstructPath(int u, int v) {
    if (next[u][v] == -1) return {};
    vector<int> path = {u};
    while (u != v) {
        u = next[u][v];
        path.push_back(u);
    }
    return path;
}
```

---

## 5. 算法分析

| 特性 | 描述 |
|------|------|
| **时间复杂度** | $ O(n^3) $，因为三重循环 |
| **空间复杂度** | $ O(n^2) $，存储距离矩阵 |
| **适用图类型** | 有向图/无向图，支持负权边，不支持负权环 |
| **是否贪心** | 否（基于动态规划） |

---

## 6. 与 Dijkstra 算法对比

| 特性 | Floyd-Warshall 算法 | Dijkstra 算法 |
|------|---------------------|----------------|
| **解决问题** | 所有顶点对之间的最短路径 | 单源最短路径 |
| **负权重边** | 支持（不含负环） | 不支持（可用 Bellman-Ford 替代） |
| **时间复杂度** | $ O(n^3) $ | $ O(E \log V) $（使用优先队列） |
| **空间复杂度** | $ O(n^2) $ | $ O(V + E) $ |
| **实现难度** | 简单 | 较复杂（尤其使用堆优化） |
| **适用场景** | 稠密图、需所有点对路径 | 稀疏图、只需单源路径 |

---

## 7. 应用场景

- **交通网络分析**：计算城市之间所有可能道路的最短距离。
- **社交网络分析**：衡量用户之间的“关系距离”。
- **路由算法**：在网络中计算所有节点之间的最短路径。
- **传递闭包计算**：判断图中任意两个顶点之间是否存在路径。

---

## 8. 注意事项

- 可用于有向图和无向图（无向图可视为双向边）。
- 若图中存在负权重环路，算法将无法正确运行。可以通过检查 `dist[i][i] < 0` 来检测负环。
- 对于稀疏图，多次调用 Dijkstra 可能比 Floyd-Warshall 更高效。

---

## 9. 总结

Floyd-Warshall 是一种简单高效的全源最短路径算法，适合处理稠密图或需要所有点对路径的场景。虽然其时间复杂度较高（$ O(n^3) $），但由于其实现简洁、逻辑清晰，在许多实际问题中仍然具有重要价值。