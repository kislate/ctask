# BFS 与并查集路径压缩

## 题目描述

跳房子游戏是西西艾弗岛上孩子们的传统娱乐方式。今天小 P 造访了西西艾弗岛，小 C 向他示范了跳房子游戏该怎么玩。

在地面上有一字排开的 $n$ 个格子，每个格子上都写着一个数字，第 $i$ 个格子上写着的数字是 $a_i$。这些数字满足 $a_i < i$ 且 $a_n = 0$。

一开始，小 C 站在第一个格子上。小 C 是一个擅长跳跃的人，他可以往前跳很远，但为了游戏的趣味性，小 C 规定在第 $i$ 个格子上最多能往前跳 $k_i$ 格，而且不能跳到第 $n$ 个格子后面。也就是说，如果小 C 现在站在第 $i$ 个格子上，那么他可以跳到第 $i+1$ 个格子和第 $\min(n, i+k_i)$ 个格子之间的任意格子上。

根据跳房子游戏的规则，如果小 C 在一次跳跃之后落到了第 $i$ 个格子上，那么他需要后退 $a_i$ 格，也就是说小 C 在跳跃后会站在第 $i-a_i$ 个格子上。

玩了一会之后，小 P 突然好奇，小 C 最少需要跳多少次才能到达第 $n$ 个格子呢？小 C 也不知道这个答案，于是他只能来请教你。

---

## 输入格式

第一行一个正整数 $n$，代表格子的数量。

第二行 $n$ 个非负整数 $a_1, a_2, \dots, a_n$，其中 $a_i$ 表示第 $i$ 个格子上的数字。

第三行 $n$ 个非负整数 $k_1, k_2, \dots, k_n$，其中 $k_i$ 表示小 C 在第 $i$ 个格子时能往前跳的最大格数。

---

## 输出格式

输出一行一个整数，表示小 C 到达第 $n$ 个格子需要的最少跳跃次数。如果小 C 不能到达第 $n$ 个格子，输出 $-1$。

---

## 代码实现

以下是优化后的代码，修复了可能存在的问题：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;
int fa[MAXN]; // 并查集数组, 用于快速找到未处理节点
int dp[MAXN]; // 记录到达每个格子的最少跳跃次数
int a[MAXN], k[MAXN]; // a[i] 和 k[i] 分别表示后退步数和最大跳跃步数
int pos[MAXN]; // 记录跳跃后的位置

// 并查集查找函数，带路径压缩
int find(int x) {
    if (fa[x] != x) 
        fa[x] = find(fa[x]); // 路径压缩优化
    return fa[x];
}

int main() {
    int n;
    cin >> n;

    // 初始化
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        dp[i] = -1; // 初始化为未访问状态
        pos[i] = i - a[i]; // 跳跃后的位置
        fa[i] = i; // 并查集初始化
    }

    for (int i = 1; i <= n; i++) 
        cin >> k[i];

    // BFS 队列
    queue<int> q;
    dp[1] = 0; // 起点跳跃次数为 0
    q.push(1);

    while (!q.empty()) {
        int i = q.front();
        q.pop();

        int start = i + 1;
        int end = i + k[i];
        if (end > n) end = n; // 防止越界
        if (start > end) continue;

        int j = find(start); // 找到第一个未处理的节点
        while (j <= end) {
            int p = pos[j]; // 跳跃后的位置
            if (dp[p] == -1) { // 如果未访问过
                dp[p] = dp[i] + 1; // 更新跳跃次数
                q.push(p); // 加入队列
            }
            fa[j] = find(j + 1); // 标记 j 为已处理
            j = find(j); // 跳到下一个未处理的节点
        }
    }

    cout << dp[n] << endl; // 输出结果
    return 0;
}
```
重点：fa[i]数组与find函数来避免重复处理

考虑使用BFS（广度优先处理），则每个节点只需被处理一次（相同节点的后续处理所用步数一定大于第一次处理）。利用fa数组则可以索引到下一个未被处理过的节点。

在代码中，fa[i] 是并查集（Union-Find）的数据结构，其核心意义是动态维护未处理的节点，实现跳跃式遍历的高效性。以下是具体解析：
fa[i] 的核心意义

    初始状态：
        每个位置 i 的 fa[i] 初始化为 i（即指向自己）。
        含义：所有位置均未被处理，属于独立的集合。
    处理过程中的动态更新：
        当处理位置 i 的跳跃范围 [i+1, i+k[i]] 时，通过 find 函数快速找到该范围内第一个未处理的节点 j。
        处理完 j 后：将 fa[j] 指向 j+1，即 fa[j] = find(j+1)。
        效果：后续再次访问到 j 时，find(j) 会直接跳过 j，返回 j+1 的根节点。
    路径压缩优化：
        find 函数通过递归路径压缩，使得每个节点的父节点直接指向根节点。
        结果：fa[i] 最终形成一个“指针链”，将所有已处理的节点链接到未处理节点的起始位置。

fa[i] 的具体作用

1. 快速定位未处理的节点

    问题：在 BFS 遍历中，每次需要处理 [i+1, i+k[i]] 范围内的节点。若逐个检查是否已处理，时间复杂度为 O(n²)。
    解决方案：
        使用 find(j) 找到范围内第一个未被处理的节点。
        例如，若 j=2 已处理，则 find(2) 返回 3，直接跳过 2。

2. 标记已处理的节点

    操作：处理完节点 j 后，执行 fa[j] = find(j+1)。
    效果：
        将 j 的父节点指向 j+1 的根节点。
        后续调用 find(j) 时，直接返回 j+1 的根节点，从而跳过 j。

3. 维护跳跃式遍历
```
    关键逻辑：

    int j = find(start);// 找到第一个未处理的节点
    while (j <= end) {
        process(j);// 处理节点 j
        fa[j] = find(j+1);// 标记 j 为已处理
        j = find(j);// 跳转到下一个未处理的节点
    }
```
过程示意图：
```
   初始状态: [1]->1, [2]->2, [3]->3, [4]->4, [5]->5
    处理 j=2 后: [2]->3, [3]->3 → find(2) 返回 3
    处理 j=3 后: [3]->4, [4]->4 → find(3) 返回 4
```
示例演算

假设 n=5，初始 fa[] = [1,2,3,4,5]：

| 步骤 | 操作 | fa[] 变化 | 说明 | | | | | | | 1 | 处理 i=1，范围 [2,3] | fa[2]=3, fa[3]=4 | find(2) 直接返回 3 → 跳过 2 | | 2 | 处理 i=3，范围 [4,6] | fa[4]=5, fa[5]=6 | find(4) 返回 5 → 处理 4 |

最终，所有节点被高效处理，无需重复检查。
为什么需要 fa[i]？

    避免重复处理：
        通过 fa[i] 的指针链，确保每个节点仅被处理一次。
    时间复杂度优化：
        传统 BFS 遍历需要 O(n²) 时间（每次检查所有跳跃位置）。
        使用并查集后，时间复杂度降至 **O(n α(n))**（接近线性）。

路径压缩的目标

    核心问题：传统的并查集在多次合并后，树可能退化成链状结构（如 1 → 2 → 3 → 4），导致查找根节点的复杂度为 **O(n)**。
    优化目标：通过压缩查找路径，使得每个节点直接指向根节点，降低后续查找的时间复杂度至 **接近 O(1)**。

路径压缩的实现

在代码中，路径压缩通过递归或迭代的查找函数实现。以下是代码中的关键函数：
```cpp
int find(int x) {
    if (fa[x] != x)
        fa[x] = find(fa[x]);// 递归路径压缩
    return fa[x];
}
```
递归压缩过程

    查找根节点：递归查找 x 的父节点，直到找到根节点（fa[root] = root）。
    压缩路径：在递归返回时，将路径上的所有节点直接指向根节点。

示例演算

假设初始树结构为 1 → 2 → 3 → 4（根节点是1）：

    调用 find(4)：
        fa[4] = 3 → 递归调用 find(3)。
        fa[3] = 2 → 递归调用 find(2)。
        fa[2] = 1 → 递归调用 find(1)（根节点）。
        回溯时更新路径：
            fa[3] = 1（原指向2，现在直接指向根1）。
            fa[4] = 1（原指向3，现在直接指向根1）。
    最终树结构：所有节点直接指向根节点 1。

路径压缩的复杂度分析

    单次查找：接近 O(1)（严格来说是 O(α(n))，其中 α 是阿克曼函数的反函数，增长极慢）。
    多次操作：经过路径压缩后，N 次操作的均摊时间复杂度接近 O(N)。

路径压缩的适用场景

    频繁查找操作：需要多次查询根节点的场景（如动态连通性问题）。
    大规模数据：当数据量极大时，路径压缩的优化效果显著。
    与 BFS/DFS 结合：在需要高效跳过已处理节点的算法中（如本题的跳跃问题）。

