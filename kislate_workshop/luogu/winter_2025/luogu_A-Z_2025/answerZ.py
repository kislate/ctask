'''
方程求解（answer）
【题目描述】
小 A 有 n 个关于 x 的方程，第 i 个方程形如 aixi + bi = ci。方程的解 x 均为正整
数，例如下面几个方程都是符合要求的方程：
2x+4=10
‐3x+13=10
4x‐8=16
其中，第一组方程的解为 x1 = 3，第二组方程的解为 x2 = 1，第三组方程的解为
x3 = 6。
小 A 想要知道，给定 L, R，在 L ≤x ≤R 的范围内，有多少个正整数 x 满足 x 是
其中至少一个方程的解。为了防止你欺骗他，他会询问你 Q 次。
【输入格式】
第一行输入两个正整数 n, Q，分别表示小 A 有的方程数，以及小 A 想要向你询问
的次数。
第二行开始，往下 n 行，每行一个字符串，描述一个方程。
第 (n + 2) 行开始，往下Q 行，每行两个正整数L, R，表示一次询问，即给定 L, R，
询问在 L ≤x ≤R 的范围内，有多少个正整数 x 满足 x 是其中至少一个方程的解。
【输出格式】
对于每次询问，输出一行一个整数，表示有多少个在 L ≤x ≤R 的范围内的正整
数 x，满足 x 是其中至少一个方程的解。
【样例 1 输入】
3 4
2x+4=10
‐3x+13=10
4x‐8=16
1 6
1 8
3 6
4 5
第 41 页 共 67 页
【样例 1 输出】
3
3
2
0
【样例 1 解释】
对于第一组样例，即为题目中的举例。三组方程的解分别为 x1 = 3, x2 = 1, x3 = 6。
则：
• 对于 1 ≤x ≤6 的范围，有 3 个 x 的取值（x = 1, 3, 6）是其中至少一个方程的
解；
• 对于 1 ≤x ≤8 的范围，同上所述；
• 对于 3 ≤x ≤6 的范围，有 2 个 x 的取值（x = 3, 6）是其中至少一个方程的解；
• 对于 4 ≤x ≤5 的范围，不存在一个 x 是其中至少一个方程的解；
• 因此分别输出 3, 3, 2, 0。
【样例 2 输入】
5 3
5x‐2=13
8x+5=45
4x‐12=8
‐2x+10=4
3x‐7=2
1 3
1 5
3 5
【样例 2 输出】
1
2
2
【样例 2 解释】
对于第二组样例，五组方程的解分别为 x1 = 3, x2 = 5, x3 = 5, x4 = 3, x5 = 3。则：
• 对于 1 ≤x ≤3 的范围，只有 x = 3 满足是其中至少一个方程的解；
• 对于 1 ≤x ≤5 的范围，有 2 个 x 的取值（x = 3, 5）是其中至少一个方程的解；
• 对于 3 ≤x ≤5 的范围，有 2 个 x 的取值（x = 3, 5）是其中至少一个方程的解；
• 因此分别输出 1, 2, 2。
【子任务】
数据保证，1 ≤n, Q ≤2 ×105，方程中 ai, bi, ci 满足 1 ≤|ai|, |bi|, |ci|≤109，每一组
方程的解 xi 必定为正整数。询问时的 L, R 满足 1 ≤L ≤R ≤2 ×109。
本题输入数据较大，请注意代码输入输出的运行效率。
【hints】
将方程作为字符串处理，是否有一些繁琐？
可否通过 getchar 函数，自行实现一个输入函数，忽略其他字符，只读入数字？
上面的函数被称为快速读入函数，可查阅资料学习。
'''


#什么鬼东西
import sys, re
import bisect

def get_Answer(equation:str) -> int:
    match = re.match(r'([+-]?\d+)x([+-]?\d+)=(-?\d+)', equation)
    a = int(match.group(1))
    b = int(match.group(2))
    c = int(match.group(3))
    if a == 0:
        return 0
    return (c - b) / a

n, Q = map(int, input().split())
answers = set()
for _ in range(n):
    equation = input()
    x = int(get_Answer(equation))
    answers.add(x)
answers = sorted(answers)
for _ in range(Q):
    L, R = map(int, input().split())
    left_index = bisect.bisect_left(answers, L)
    right_index = bisect.bisect_right(answers, R)
    print(right_index - left_index)



    
