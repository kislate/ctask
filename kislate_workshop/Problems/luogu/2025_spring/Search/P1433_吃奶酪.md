# P1433 吃奶酪

## 题目描述

房间里放着 $n$ 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 $(0,0)$ 点处。

## 输入格式

第一行有一个整数，表示奶酪的数量 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行两个实数，第 $(i + 1)$ 行的实数分别表示第 $i$ 块奶酪的横纵坐标 $x_i, y_i$。

## 输出格式

输出一行一个实数，表示要跑的最少距离，保留 $2$ 位小数。

## 输入输出样例 #1

### 输入 #1

```
4
1 1
1 -1
-1 1
-1 -1
```

### 输出 #1

```
7.41
```

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1\leq n\leq 15$，$|x_i|, |y_i| \leq 200$，小数点后最多有 $3$ 位数字。

#### 提示

对于两个点 $(x_1,y_1)$，$(x_2, y_2)$，两点之间的距离公式为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

---

$2022.7.13$：新增加一组 $\text{Hack}$ 数据。
## 下面是尝试代码:
### 直接$dfs$最多只能拿90分:
```cpp
for(double i = 0; i <= n; i++)
        for(double j = 0; j <= n; j++)
            predistance[i][j] = cal_distanc(i, j);
```
$$ 可以尝试提前计算,但其实也无法优化$$
```cpp
#include <bits/stdc++.h>
using namespace std;
double n, cnt = 0;
vector<pair<double, double>> cheeses;
vector<double> visited;
double cal_distanc(double x1, double x2)
{
    return sqrt((cheeses[x1].first - cheeses[x2].first) * (cheeses[x1].first - cheeses[x2].first) + (cheeses[x1].second - cheeses[x2].second) * (cheeses[x1].second - cheeses[x2].second));
}
double min_distance = 1e9;
void dfs(double x, double dis);
int main(void){
    cin >> n;
    cheeses.resize(n+1, {0, 0});
    visited.resize(n, 0);
    for(double i = 0; i < n; i++) cin >> cheeses[i].first >> cheeses[i].second;
    for(double i = 0; i < n; i++)
    {
        visited[i] = 1, cnt++;
        dfs(i, cal_distanc(n, i));
        visited[i] = 0, cnt--;
    }
    cout << fixed << setprecision(2) << min_distance << endl;
    return 0;
}
void dfs(double x, double dis)
{
    if(cnt == n)
    {
        min_distance = min(min_distance, dis);
        return;
    }
    for(double i = 0; i < n; i++)
    {
        if(visited[i] == 0)
        {
            double distance = cal_distanc(x, i);
            if(dis + distance > min_distance) return;
            visited[i] = 1, cnt++;
            dfs(i, dis + distance);
            visited[i] = 0, cnt--;
        }
    }
}
```
```cpp
#include <bits/stdc++.h>
using namespace std;
float cal_dis(int x1, int y1, int x2, int y2)
{
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

int n;
vector<pair<double, double>> cheese;
double dp[1<<16][16];

double cal_dis(double x1, double y1, double x2, double y2) {
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

int main() {
    cin >> n;
    cheese.push_back({0,0});=
    for(int i=1;i<=n;i++) {
        double x, y;
        cin >> x >> y;
        cheese.push_back({x, y});
    }
    int N = n+1;
    int full = (1<<N)-1;
    for(int i=0;i<(1<<N);i++)
        for(int j=0;j<N;j++)
            dp[i][j]=1e18;
    dp[1][0]=0; // 只在原点

    for(int mask=1;mask<(1<<N);mask++) {
        for(int u=0;u<N;u++) {
            if(!(mask&(1<<u))) continue;
            for(int v=1;v<N;v++) {
                if(mask&(1<<v)) continue;
                int next=mask|(1<<v);
                double d=cal_dis(cheese[u].first,cheese[u].second,cheese[v].first,cheese[v].second);
                dp[next][v]=min(dp[next][v],dp[mask][u]+d);
            }
        }
    }
    double ans=1e18;
    for(int i=1;i<N;i++) {
        ans=min(ans,dp[full][i]);
    }
    printf("%.2f\n",ans);
    return 0;
}
```