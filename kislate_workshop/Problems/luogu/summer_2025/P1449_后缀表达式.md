# P1449 后缀表达式

## 题目描述

所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。

本题中运算符仅包含 $\texttt{+-*/}$。保证对于 $\texttt{/}$ 运算除数不为 0。特别地，其中 $\texttt{/}$ 运算的结果需要**向 0 取整**（即与 C++ `/` 运算的规则一致）。

如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，`@` 为表达式的结束符号。`.` 为操作数的结束符号。

## 输入格式

输入一行一个字符串 $s$，表示后缀表达式。

## 输出格式

输出一个整数，表示表达式的值。

## 输入输出样例 #1

### 输入 #1

```
3.5.2.-*7.+@
```

### 输出 #1

```
16
```

## 输入输出样例 #2

### 输入 #2

```
10.28.30./*7.-@
```

### 输出 #2

```
-7
```

## 说明/提示

数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。# P1449 后缀表达式

## 题目描述

所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。

本题中运算符仅包含 $\texttt{+-*/}$。保证对于 $\texttt{/}$ 运算除数不为 0。特别地，其中 $\texttt{/}$ 运算的结果需要**向 0 取整**（即与 C++ `/` 运算的规则一致）。

如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，`@` 为表达式的结束符号。`.` 为操作数的结束符号。

## 输入格式

输入一行一个字符串 $s$，表示后缀表达式。

## 输出格式

输出一个整数，表示表达式的值。

## 输入输出样例 #1

### 输入 #1

```
3.5.2.-*7.+@
```

### 输出 #1

```
16
```

## 输入输出样例 #2

### 输入 #2

```
10.28.30./*7.-@
```

### 输出 #2

```
-7
```

## 说明/提示

数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。

## 我和AI无敌:
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef struct{
    int num;
    char op = '!';
} Elem;
stack<Elem> s;
bool is_op(Elem);
void get_input();
int postfix_notation();
int main(void)
{
    get_input();
    int result = postfix_notation();
    cout << result << endl;
    return 0;
}

int postfix_notation()
{
    if(s.empty()){
        return 0;
    }
    Elem e = s.top();
    s.pop();
    if(!is_op(e)){
        return e.num;
    }
    if(is_op(e)){
        if(e.op == '+')
        {
            int left = postfix_notation();
            int right = postfix_notation();
            //cout << left << " + " << right << endl; // 输出当前操作
            return left + right;
            // return postfix_notation() + postfix_notation();
        }
        else if(e.op == '-')
        {
            int left = postfix_notation();
            int right = postfix_notation();
            //cout << left << " - " << right << endl; // 输出当前操作
            return right - left;
        }
        else if(e.op == '*')
        {
            int left = postfix_notation();
            int right = postfix_notation();
            //cout << left << " * " << right << endl; // 输出当前操作
            return left * right;
            // return postfix_notation() * postfix_notation();
        }
        else if(e.op == '/')
        {
            int left = postfix_notation();
            int right = postfix_notation();
            //cout << left << " / " << right << endl; // 输出当前操作
            return right / left;
            // return postfix_notation() / postfix_notation();
        }
    }
    return 0; // Fallback return, should not reach here if input is valid
}

bool is_op(Elem e)
{
    return e.op == '+' || e.op == '-' || e.op == '*' || e.op == '/';
}

void get_input()
{
    string input;
    getline(cin, input);
    
    // 去除结尾的 '@'
    if (!input.empty() && input.back() == '@') {
        input.pop_back();
    }
    
    //cout << input << endl; // 输出输入的字符串
    
    string token = "";
    for (char c : input) {
        if (c == '.') {
            // 遇到 '.' 说明前面是一个数字
            if (!token.empty()) {
                Elem e;
                e.num = stoi(token);
                s.push(e);
                //cout << token << endl;
                token = "";
            }
        } else if (c == '+' || c == '-' || c == '*' || c == '/') {
            // 遇到运算符，直接处理
            Elem e;
            e.op = c;
            s.push(e);
            //cout << c << endl;
        } else {
            // 数字字符，累积到token中
            token += c;
        }
    }
    
    // 处理最后一个token（如果有的话）
    if (!token.empty()) {
        Elem e;
        e.num = stoi(token);
        s.push(e);
        cout << token << endl;
    }
}
```