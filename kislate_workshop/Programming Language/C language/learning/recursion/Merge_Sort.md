# 归并排序 (Merge Sort)

归并排序是一种有效的、稳定的、基于比较的排序算法。它采用了分治法（Divide and Conquer）的策略，将一个大的问题分解成若干个小问题来解决，然后将解决了的小问题合并，最终解决整个大问题。

## 算法步骤

1. **分解**：将待排序数组分成两个长度相等的子数组。
2. **递归**：对每个子数组递归地进行归并排序。
3. **合并**：将两个已排序的子数组合并成一个有序的数组。

## 详细过程

假设有一个数组 `A`，其长度为 `n`：

1. 如果数组 `A` 的长度为 1 或 0，则数组已经有序，直接返回。
2. 将数组 `A` 分成两个子数组 `A1` 和 `A2`，其中 `A1` 包含前 `n/2` 个元素，`A2` 包含后 `n/2` 个元素。
3. 递归地对 `A1` 和 `A2` 进行归并排序。
4. 将排序后的 `A1` 和 `A2` 合并成一个有序的数组。

## 伪代码

```markdown
function mergeSort(A):
	if length(A) <= 1:
		return A
	mid = length(A) / 2
	left = mergeSort(A[0:mid])
	right = mergeSort(A[mid:length(A)])
	return merge(left, right)

function merge(left, right):
	result = []
	while left is not empty and right is not empty:
		if left[0] <= right[0]:
			append left[0] to result
			left = left[1:]
		else:
			append right[0] to result
			right = right[1:]
	append any remaining elements of left to result
	append any remaining elements of right to result
	return result
```

## 时间复杂度

归并排序的时间复杂度为 `O(n log n)`，其中 `n` 是待排序数组的长度。归并排序的时间复杂度分析如下：

- 分解阶段：将数组分成两个子数组，时间复杂度为 `O(log n)`。
- 合并阶段：合并两个已排序的子数组，时间复杂度为 `O(n)`。

因此，归并排序的总时间复杂度为 `O(n log n)`。

## 空间复杂度

归并排序的空间复杂度为 `O(n)`，因为在合并阶段需要额外的数组来存储合并后的结果。

## 优缺点

### 优点

- **稳定性**：归并排序是稳定的排序算法。
- **时间复杂度**：在最坏情况下，归并排序的时间复杂度为 `O(n log n)`。
- **适用性**：适用于大规模数据的排序。

### 缺点

- **空间复杂度**：归并排序需要额外的空间来存储合并后的结果，空间复杂度为 `O(n)`。

## 示例

```markdown
输入: [38, 27, 43, 3, 9, 82, 10]
输出: [3, 9, 10, 27, 38, 43, 82]
```

归并排序的过程如下：

1. 分解：[38, 27, 43, 3, 9, 82, 10] -> [38, 27, 43] 和 [3, 9, 82, 10]
2. 递归排序：[38, 27, 43] -> [27, 38, 43] 和 [3, 9, 82, 10] -> [3, 9, 10, 82]
3. 合并：[27, 38, 43] 和 [3, 9, 10, 82] -> [3, 9, 10, 27, 38, 43, 82]
## 例题

### 例题 1

**题目**: 使用归并排序对以下数组进行排序：`[12, 11, 13, 5, 6, 7]`

**解答**:

1. 分解：[12, 11, 13, 5, 6, 7] -> [12, 11, 13] 和 [5, 6, 7]
2. 递归排序：[12, 11, 13] -> [11, 12, 13] 和 [5, 6, 7] -> [5, 6, 7]
3. 合并：[11, 12, 13] 和 [5, 6, 7] -> [5, 6, 7, 11, 12, 13]

最终结果为 `[5, 6, 7, 11, 12, 13]`

### 例题 2

**题目**: 使用归并排序对以下数组进行排序：`[4, 1, 3, 9, 7]`

**解答**:

1. 分解：[4, 1, 3, 9, 7] -> [4, 1, 3] 和 [9, 7]
2. 递归排序：[4, 1, 3] -> [1, 3, 4] 和 [9, 7] -> [7, 9]
3. 合并：[1, 3, 4] 和 [7, 9] -> [1, 3, 4, 7, 9]

最终结果为 `[1, 3, 4, 7, 9]`